<svg xmlns="http://www.w3.org/2000/svg" height={height}px width={width}px>
	<text
		fill={baseColor}
		style="font-size: {fontSize}px;"
		text-anchor=end
		x={ leftMargin - plotXMargin - tickLength - (labelBuffer * 2)}
		y={ calculatePlotY(minsAndMaxes.maxY) }
		dy=4
	>
		{ formatY(minsAndMaxes.maxY) }
	</text>
	<text
		fill={baseColor}
		style="font-size: {fontSize}px;"
		text-anchor=end
		x={ leftMargin - plotXMargin - tickLength - (labelBuffer * 2)}
		y={ calculatePlotY(minsAndMaxes.minY) }
		dy=4
	>
		{ formatY(minsAndMaxes.minY) }
	</text>
	<text
		fill={baseColor}
		style="font-size: {fontSize}px;"
		text-anchor=middle
		x={ calculatePlotX(minsAndMaxes.maxX) }
		y={ topMargin + plotHeight + plotYMargin + tickLength + labelBuffer}
		dy={fontSize}
	>
		{ formatX(minsAndMaxes.maxX) }
	</text>
	<text
		fill={baseColor}
		style="font-size: {fontSize}px;"
		text-anchor=middle
		x={ calculatePlotX(minsAndMaxes.minX) }
		y={ topMargin + plotYMargin + plotHeight + tickLength + labelBuffer}
		dy={fontSize}
	>
		{ formatX(minsAndMaxes.minX) }
	</text>


	{#if leftFrame === 'ticks'}
		{#each dataset.points as point}
			<line
				x1={leftMargin - plotXMargin - tickLength}px
				x2={leftMargin - plotXMargin}px
				y1={calculatePlotY(point.y)}px
				y2={calculatePlotY(point.y)}px
				stroke={dataset.color}
				stroke-width={tickWidth}px
			/>
		{/each}
	{:elseif leftFrame === 'line'}
		<line
			x1={leftMargin - plotXMargin}px
			x2={leftMargin - plotXMargin}px
			y1={calculatePlotY(minsAndMaxes.minY)}px
			y2={calculatePlotY(minsAndMaxes.maxY)}px
			stroke={baseColor}
			stroke-width=1px
		/>
	{/if}

	{#each dataset.points as point}
		<circle
			cx={calculatePlotX(point.x)}px
			cy={calculatePlotY(point.y)}px
			r={pointSize}
			fill={dataset.color}
			on:mouseenter=hover(point)
		/>
	{/each}

	{#if bottomFrame === 'ticks'}
		{#each dataset.points as point}
			<line
				x1={calculatePlotX(point.x)}px
				x2={calculatePlotX(point.x)}px
				y1={topMargin + plotYMargin + plotHeight}px
				y2={topMargin + plotYMargin + plotHeight + tickLength}px
				stroke={dataset.color}
				stroke-width={tickWidth}px
			/>
		{/each}
	{:elseif bottomFrame === 'line'}
		<line
			x1={calculatePlotX(minsAndMaxes.minX)}px
			x2={calculatePlotX(minsAndMaxes.maxX)}px
			y1={topMargin + plotYMargin + plotHeight}px
			y2={topMargin + plotYMargin + plotHeight}px
			stroke={baseColor}
			stroke-width=1px
		/>
	{/if}

	{#if hoveredPoint}
		<circle
			cx={calculatePlotX(hoveredPoint.x)}px
			cy={calculatePlotY(hoveredPoint.y)}px
			r={pointSize * 2}
			fill={highlightColor}
			on:mouseleave=hover(null)
		/>

		<line
			x1={leftMargin - plotXMargin - tickLength}px
			x2={leftMargin - plotXMargin}px
			y1={calculatePlotY(hoveredPoint.y)}px
			y2={calculatePlotY(hoveredPoint.y)}px
			stroke={highlightColor}
			stroke-width={tickWidth * 10}px
		/>

		<line
			x1={calculatePlotX(hoveredPoint.x)}px
			x2={calculatePlotX(hoveredPoint.x)}px
			y1={topMargin + plotYMargin + plotHeight}px
			y2={topMargin + plotYMargin + plotHeight + tickLength}px
			stroke={highlightColor}
			stroke-width={tickWidth * 10}px
		/>

	{/if}

</svg>

<script>
const max = (maybeNull, number) => maybeNull === null ? number : Math.max(maybeNull, number)
const min = (maybeNull, number) => maybeNull === null ? number : Math.min(maybeNull, number)

const identity = value => value

export default {
	data() {
		return {
			leftMargin: 100,
			rightMargin: 50,
			topMargin: 40,
			bottomMargin: 80,

			width: 600,
			height: 300,

			bottomFrame: `ticks`,
			leftFrame: `ticks`,
			pointSize: 2,
			tickLength: 10,
			tickWidth: 0.2,
			labelBuffer: 4,

			dataset: {
				points: [],
				color: `black`,
			},
			formatX: identity,
			formatY: identity,
			plotYMargin: 20,
			plotXMargin: 20,

			fontSize: 16,
			baseColor: `#797979`,
			highlightColor: `#9A0000`,
		}
	},
	methods: {
		hover(hoveredPoint) {
			this.set({
				hoveredPoint,
			})
		},
	},
	computed: {
		plotWidth: ({ width, leftMargin, rightMargin }) => width - leftMargin - rightMargin,
		plotHeight: ({ height, bottomMargin, topMargin }) => height - bottomMargin - topMargin,
		calculatePlotX: ({ leftMargin, plotWidth, minsAndMaxes, dataRanges }) => x => {
			const xRatio = ((x - minsAndMaxes.minX) / dataRanges.x)

			return leftMargin + (xRatio * plotWidth)
		},
		calculatePlotY: ({ plotHeight, minsAndMaxes, dataRanges, topMargin }) => y => {
			const yRatio = ((y - minsAndMaxes.minY) / dataRanges.y)

			return topMargin + plotHeight - (yRatio * plotHeight)
		},
		minsAndMaxes: ({ dataset }) => dataset.points.reduce(({ minX, maxX, minY, maxY }, { x, y }) => ({
			minX: min(minX, x),
			maxX: max(maxX, x),
			minY: min(minY, y),
			maxY: max(maxY, y),
		}), { minX: null, maxX: null, minY: null, maxY: null }),
		dataRanges: ({ minsAndMaxes }) => ({
			x: minsAndMaxes.maxX - minsAndMaxes.minX,
			y: minsAndMaxes.maxY - minsAndMaxes.minY,
		}),
	},
}
</script>

